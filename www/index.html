<!DOCTYPE html>
<html lang="en">

<head>
    <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet/v1.6.0/leaflet.css" />
    <script src="http://cdn.leafletjs.com/leaflet/v1.6.0/leaflet.js"></script>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet.locatecontrol/dist/L.Control.Locate.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/leaflet.locatecontrol/dist/L.Control.Locate.min.js"
        charset="utf-8"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css">
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-geosearch@2.7.0/dist/style.css">
    <script src="https://unpkg.com/leaflet-geosearch@2.7.0/dist/bundle.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-geosearch@2.6.0/assets/css/leaflet.css">
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.15/lodash.min.js"></script>

    <!-- CSS only -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
    <!-- JS, Popper.js, and jQuery -->
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js" integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI" crossorigin="anonymous"></script>
    
    <style>
        html, body {
            height: 100%;
            width: 100%;
        }

        .min-100 {
            min-height: 100%;
        }

        #map {
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <div class="container-fluid h-100 d-flex flex-column p-0">
        <nav class="navbar bg-primary flex-shrink-0 justify-content-between">
            <a class="navbar-brand" href="#">
                <img src="https://mdbootstrap.com/img/logo/mdb-transparent.png" height="30" alt="mdb logo">
            </a>            
        </nav>
        <div class="row flex-grow-1 m-0">
            <div id="map"></div>
        </div>
    </div>
    
    

    <script>
        const API_ENDPOINT = "http://localhost:8080"
        const MIN_ZOOM_TO_SHOW_DATA = 14

        var POTHOLE_ICON = L.icon({
            iconUrl: '/static/img/pot-hole-marker.png',
            iconSize: [70, 70], // size of the icon
            iconAnchor: [35, 70], // point of the icon which will correspond to marker's location
            popupAnchor: [35, 0] // point from which the popup should open relative to the iconAnchor
        });

        var roadIssuesMarkerCluster = L.markerClusterGroup();
        var legsLayer = L.layerGroup();
        var overlayMaps = {
            "Road status": legsLayer,
            "Road issues": roadIssuesMarkerCluster
        };

        var mymap = L.map('map', {
            center: [44.133331, 12.233333],
            zoom: 18,
            maxNativeZoom: 18,
            maxZoom: 18,
            minZoom: 6,
            zoomControl: false,
            layer: [roadIssuesMarkerCluster, legsLayer]
        });

        var MAPBOX_TOKEN = 'pk.eyJ1IjoiZ2lhY29tb3RvbnRpbmkiLCJhIjoiY2s5Y3h0d2hxMDNjYjNtcGxmYTA3dnYzMSJ9.EoujETnFYtRxAox-ne97mQ'
        L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/streets-v11/tiles/256/{z}/{x}/{y}?access_token=' + MAPBOX_TOKEN, {
            attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(mymap);

        L.control.layers(null, overlayMaps).addTo(mymap)
        L.control.zoom({
            position: 'bottomright'
        }).addTo(mymap);
        legsLayer.addTo(mymap)
        roadIssuesMarkerCluster.addTo(mymap)

        var lc = L.control.locate({
            position: 'bottomright',
            flyTo: true,
            circleStyle: {
                fillOpacity: 0.07
            },
            locateOptions: {
                enableHighAccuracy: true,
                maxZoom: 18
            },
            strings: {
                title: "Show me where I am, yo!"
            }
        }).addTo(mymap);
        lc.start()


        const provider = new window.GeoSearch.OpenStreetMapProvider();
        const searchControl = new window.GeoSearch.GeoSearchControl({
            provider: provider,
            style: 'bar',
            showMarker: false,
            autoClose: true,
            retainZoomLevel: true,
            searchLabel: 'Looking for new places?'
        });
        mymap.addControl(searchControl);


        let obstacleCache = new Map() // cache for obstacles: "{type},{lat},{lng}" -> marker
        function drawObstacle(coordinates, type) {
            let key = type + "," + coordinates[0] + "," + coordinates[1]
            if (!obstacleCache.has(key)) {
                var icon = POTHOLE_ICON
                if (type == "POTHOLE") {
                    console.log('pothole added')
                } else if (type == "SPEED_BUMP") {
                    console.log('speed bump added')
                } else if (type == "MANHOLE") {
                    console.log('manhole added')
                } else if (type == "JOINT") {
                    console.log('expansion joint added')
                }
                var marker = L.marker(coordinates, {
                    icon: icon
                })
                roadIssuesMarkerCluster.addLayer(marker);
                obstacleCache.set(key, marker)
            }
        }

        function drawObstacles(obstaclesJson) {
            if (obstaclesJson != null) {
                for (var obstacleType of Object.keys(obstaclesJson)) {
                    obstaclesJson[obstacleType].forEach(obstacle => drawObstacle([obstacle.latitude, obstacle.longitude], obstacleType))
                }
            }
        }

        let legCache = new Map()
        let qualityToColor = {
            0: "lightgreen",
            1: "green",
            2: "yellow",
            3: "red",
            4: "darkred"
        };
        function drawLegs(legsJsonArray) {
            legsJsonArray.forEach(leg => {
                var legObj = JSON.stringify({ from: leg.from, to: leg.to })
                if (!legCache.has(legObj)) {
                    var polyline = L.polyline([
                        [leg.from.coordinates.latitude, leg.from.coordinates.longitude],
                        [leg.to.coordinates.latitude, leg.to.coordinates.longitude]],
                        { color: qualityToColor[leg.quality], weight: 5 }
                    ).addTo(legsLayer);
                    legCache.set(legObj, polyline)
                } else {
                    var polylineCached = legCache.get(legObj)
                    if (polylineCached.color != qualityToColor[leg.quality]) {
                        polylineCached.setStyle({
                            color: qualityToColor[leg.quality]
                        });
                    }
                }
                drawObstacles(leg.obstacles)
            });
        }

        var lastPositionUsedForUpdate = mymap.getCenter()
        var previousZoom = mymap.getZoom()
        mymap.on('movestart', ev => {
            previousZoom = mymap.getZoom()
        });

        /*
        mymap.on('move', ev => {
            if (ev.flyTo != true && !mymap.getBounds().contains(lastPositionUsedForUpdate) && mymap.getZoom() > MIN_ZOOM_TO_SHOW_DATA) {
                updateEvaluationAsync()
                console.log("[move] new data requested", ev)
            }
        });
        */

        mymap.on('moveend', ev => {
            if (
                (
                    (previousZoom < mymap.getZoom() && previousZoom <= MIN_ZOOM_TO_SHOW_DATA) || //zoom in, zoomed enough
                    (ev.flyTo != true && previousZoom > mymap.getZoom()) || //zoom out, still zoomed over minimum
                    (!mymap.getBounds().contains(lastPositionUsedForUpdate)) // moved out of boundaries
                ) && mymap.getZoom() > MIN_ZOOM_TO_SHOW_DATA) {
                updateEvaluationAsync()
                console.log("[moveEnd] new data requested", ev)
            }
        });


        function updateEvaluationAsync() {
            lastPositionUsedForUpdate = mymap.getCenter()
            axios.get(API_ENDPOINT + '/roads/evaluations', {
                params: {
                    latitude: lastPositionUsedForUpdate.lat,
                    longitude: lastPositionUsedForUpdate.lng,
                    radius: mymap.getBounds().getCenter().distanceTo(mymap.getBounds().getNorthWest())
                }
            }).then(response => {
                if (response.status = "200") {
                    drawLegs(response.data)
                } else {
                    console.log('GET request on /roads/evaluations went wrong.')
                }
            })
            .catch(function (error) {
                console.log('An error occurred on /roads/evaluations GET request: ' + error);
            });
            console.log('called')
        }

        const interval = setInterval(() => {
            if (mymap.getZoom() > MIN_ZOOM_TO_SHOW_DATA) {
                updateEvaluationAsync()
            }
        }, 10000); //periodic update (ms)
    </script>
</body>

</html>